# This workflow either scans all distribute-able projects with snyk, or updates the relevant
# projects on the Snyk servers
name: Zeebe Snyk

on:
  workflow_dispatch:
    inputs:
      version:
        description: The project version; defaults to the version as defined by the root POM
        required: false
        type: string
      target:
        description: Allows overriding the project target reference directly; defaults to the current branch
        required: false
        type: string
      dockerImage:
        description: The full name of the Docker image; if absent and build is true, will use the built image name; if not building, infers from the version
        required: false
        type: string
      monitor:
        description: Upload Snyk snapshot instead of test
        required: false
        type: boolean
        default: false
      build:
        description: Enable to also build Zeebe
        required: false
        type: boolean
        default: true
      useMinorVersion:
        description: Uses the major and minor version only for target and version
        required: false
        type: boolean
        default: false
      ref:
        description: The reference to checkout
        required: false
        type: string
  workflow_call:
    secrets:
      SNYK_TOKEN:
        required: true
    inputs:
      version:
        description: The project version; defaults to the version as defined by the root POM
        required: false
        type: string
      target:
        description: Allows overriding the project target reference directly; defaults to the current branch
        required: false
        type: string
      dockerImage:
        description: The full name of the Docker image; if absent and build is true, will use the built image name; if not building, infers from the version
        required: false
        type: string
      monitor:
        description: Upload Snyk snapshot instead of test
        required: false
        type: boolean
        default: false
      build:
        description: Enable to also build Zeebe
        required: false
        type: boolean
        default: true
      useMinorVersion:
        description: Uses the major and minor version only for target and version
        required: false
        type: boolean
        default: false
      ref:
        description: The reference to checkout
        required: false
        type: string

defaults:
  run:
    # use bash shell by default to ensure pipefail behavior is the default
    # see https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#exit-codes-and-error-action-preference
    shell: bash

jobs:
  scan:
    name: Snyk Scan
    # Run on self-hosted to make building Zeebe much faster
    runs-on: gcp-perf-core-8-default
    permissions:
      security-events: write # required to upload SARIF files
    steps:
      - name: Install Snyk CLI
        uses: snyk/actions/setup@master
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
      - name: Import Secrets
        id: secrets
        uses: hashicorp/vault-action@v3.0.0
        with:
          url: ${{ secrets.VAULT_ADDR }}
          method: approle
          roleId: ${{ secrets.VAULT_ROLE_ID }}
          secretId: ${{ secrets.VAULT_SECRET_ID }}
          secrets: |
            secret/data/products/zeebe/ci/zeebe ARTIFACTS_PSW;
            secret/data/products/zeebe/ci/zeebe ARTIFACTS_USR;
            secret/data/products/zeebe/ci/zeebe REGISTRY_HUB_DOCKER_COM_PSW_READ_ONLY;
            secret/data/products/zeebe/ci/zeebe REGISTRY_HUB_DOCKER_COM_USR;
      - uses: ./.github/actions/setup-build
        with:
          camunda-nexus-username: ${{ steps.secrets.outputs.ARTIFACTS_USR }}
          camunda-nexus-password: ${{ steps.secrets.outputs.ARTIFACTS_PSW }}
          maven-cache-key-modifier: snyk
      # We need to build the Docker image (and thus the distribution) to scan it
      - name: Build Zeebe Distribution
        uses: ./.github/actions/build-zeebe
        id: build-zeebe
        if: inputs.build
      # Logging to DockerHub to to avoid being rate-limited when using an anonymous account from GitHub-managed runners.
      # jib-maven-plugin uses eclipse-temurin:xx image from DockerHub as base.
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_USR }}
          password: ${{ steps.secrets.outputs.REGISTRY_HUB_DOCKER_COM_PSW_READ_ONLY }}
      - name: Build Docker Image
        uses: ./.github/actions/build-platform-docker
        id: build-zeebe-docker
        if: inputs.build
        with:
          distball: ${{ steps.build-zeebe.outputs.distball }}
      # Prepares the bash environment for the step which will actually run Snyk, to avoid mixing too
      # much the GitHub Action contexts/syntax and bash itself.
      - name: Build Snyk Environment
        id: info
        run: |
          set -x

          export TARGET=$([[ ! -z '${{ inputs.target }}' ]] && echo '${{ inputs.target }}' || echo "${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}")
          export VERSION=$([[ ! -z '${{ inputs.version }}' ]] && echo '${{ inputs.version }}' || ./mvnw -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive exec:exec 2>/dev/null)
          export VERSION_TAG=$([[ "${VERSION}" == *-SNAPSHOT ]] && echo 'development' || echo "${VERSION}")
          export LIFECYCLE=$([[ "${VERSION}" == *-SNAPSHOT ]] && echo 'development' || echo 'production')

          # use inputs.dockerImage if present; otherwise if building, use the output of the build step; otherwise infer from version and default repository camunda/zeebe
          export DOCKER_IMAGE=$([[ ! -z '${{ inputs.dockerImage }}' ]] && echo '${{ inputs.dockerImage }}' || ([[ '${{ inputs.build }}' == 'true' ]] && echo '${{ steps.build-zeebe-docker.outputs.image }}' || echo "camunda/zeebe:${VERSION}"))

          if [[ '${{ inputs.useMinorVersion }}' == 'true' ]]; then
            export TARGET="$(echo $VERSION | sed -E -e 's/\.[^.]*$//')"
          fi

          echo "SNYK_ARGS=" \
            "--show-vulnerable-paths=all" \
            "--severity-threshold=high" \
            "--org=team-zeebe" \
            "--project-lifecycle=${LIFECYCLE}" \
            "--project-tags=version=${VERSION_TAG}" \
            "--target-reference=${TARGET}" >> $GITHUB_ENV
          echo "TARGET=${TARGET}" >> $GITHUB_ENV
          echo "SNYK_COMMAND=${{ (inputs.monitor && 'monitor') || 'test' }}" >> $GITHUB_ENV
          echo "SARIF=${{ (inputs.monitor && 'false') || 'true' }}" >> $GITHUB_ENV
          echo "DOCKER_IMAGE=${DOCKER_IMAGE}" >> $GITHUB_ENV
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
      - name: Run Snyk
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        # The script is set up to scan all distributable artifacts: the projects listed in the bom,
        # the Go client, and the official Docker image.
        # If we add things to the BOM, for example, we should also add them here to the
        # JAVA_PROJECTS variable.
        run: |
          # To avoid exiting on the first failure, we instead flip this to 1 as soon as one of the
          # command fails, and return this at the end; anything non 0 will cause the step to fail
          exitCode=0
          JAVA_PROJECTS=(bom clients/java clients/spring-boot-starter-camunda-sdk zeebe/bpmn-model zeebe/exporter-api zeebe/gateway-protocol-impl zeebe/protocol)

          # Remember that when called from a sub-shell, the environment/globals are different
          function output() {
            local sarif="$1"
            local name="$2"
            [ "${sarif}" == 'true' ] && echo "--sarif-file-output=sarif-results/${name}.sarif"
          }

          function ensureExists() {
            local projectFile="$1"
            if [ ! -f "${projectFile}" ]; then
              echo "Cannot find project file to scan: [ ${projectFile} ]"
              exit 1
            fi
          }

          # Print out command if debug logging is enabled
          set -x

          # Project names contain the target branch, setting the target reference is not yet supported
          # for containers. So projects are named using this pattern: `zeebe(BRANCH):path/to/buildFile`
          #
          # Since the snyk CLI here pass the command as a string, any parenthesis will break the eval
          # call. As such, we need to double escape the `--project-name` in single quotes
          for project in "${JAVA_PROJECTS[@]}"; do
            PROJECT_NAME="zeebe(${TARGET}):${project}/pom.xml"
            ensureExists "${project}/pom.xml"
            snyk "${SNYK_COMMAND}" --file=${project}/pom.xml "'--project-name=${PROJECT_NAME}'" ${SNYK_ARGS} "$(output "${SARIF}" "${project/\//-}")" || exitCode=1
          done

          # The `container` command does not yet support setting a target reference, as this is a beta
          # feature at the moment. It's added here anyway for now, and hopefully support will come soon.
          PROJECT_NAME="zeebe(${TARGET}):Dockerfile"
          ensureExists "Dockerfile"
          snyk container "${SNYK_COMMAND}" "${DOCKER_IMAGE}" --file=Dockerfile "'--project-name=${PROJECT_NAME}'" ${SNYK_ARGS} "$(output "${SARIF}" 'docker')" || exitCode=1

          # Only fail if we entirely failed to parse the projects
          if [[ $exitCode -gt 1 ]]; then
            exit "${exitCode}"
          else
            exit 0
          fi
      - name: Code Scanning summary
        if: ${{ ! inputs.monitor }}
        run: |
          export PR_NUMBER=$(echo $GITHUB_REF | awk 'BEGIN { FS = "/" } ; { print $3 }')
          cat >> $GITHUB_STEP_SUMMARY <<EOF
            ## Result Links
            - [Snyk projects](https://app.snyk.io/org/team-zeebe/projects)
          EOF
      - name: Observe build status
        if: always()
        continue-on-error: true
        uses: ./.github/actions/observe-build-status
        with:
          build_status: ${{ job.status }}
          secret_vault_address: ${{ secrets.VAULT_ADDR }}
          secret_vault_roleId: ${{ secrets.VAULT_ROLE_ID }}
          secret_vault_secretId: ${{ secrets.VAULT_SECRET_ID }}
